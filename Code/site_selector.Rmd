---
title: "Site selector data visualization tool"
author: "Molly 'Caz' Bell and A.J. Brown using R version 4.2.2"
date: "`r Sys.Date()`"
output: 
  html_document:
    output_dir: "site_selector_temporary_results"
    toc: yes
    toc_float:
      collapsed: no
      smooth_scroll: no
---

# Introduction and Metadata
The following is an interactive data report containing water quality data from 
samples taken by the Colorado State University (CSU) Agriculture Water Quality 
Program (AWQP) at a location selected by the user when running the script
(reported below). For more information, please contact A.J. Brown at
Ansley.Brown@colostate.edu or visit the CSU AWQP Website at 
https://waterquality.colostate.edu.

**Please Note:** All analytes are reported in mg/L *EXCEPT*
selenium (reported in ug/L), specific electrical conductivity (EC; mS/cm), and
pH (log H).

**Misc. Notes**

*	All “0” values reported are non-detects (ND) reported by ALS
*	Total suspended solids (TSS), Electrical Conductivity (EC), and pH are performed by AWQP staff at CSU, whereas all other analytes are reported by ALS Laboratories
*	Methods used to derive each analyte can be found in the Raw Data table in the “method” column

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
knitr::opts_knit$set(root.dir = here::here())
```

```{r, include=FALSE}
# packages
package.list <- c('plotly','dplyr','tidyr','DT','ggplot2','lubridate','tools','stringr','tibble')
packageLoad <- function(packages){
  for (i in packages) {
    if (!require(i, character.only = TRUE)) {
      install.packages(i, repos = "http://cran.us.r-project.org")
      library(i, character.only = TRUE)
    }
  }
}
packageLoad(package.list)
```

```{r, include=FALSE}
# Data build
source('./Code/file-merger.R')
dat <- returnAllFiles(d = directory, export = FALSE)
colnames(dat) <- tolower(names(dat))
```

```{r, include=FALSE}
# ---- Site list (toggle exactly ONE 'loc' line) ----
# loc <- 'ARDEC'                     
# loc <- 'AVRC STAR'
# loc <- 'AVRC Cowpea'
# loc <- 'Barley'
# loc <- 'Berthoud'
# loc <- 'Big Hollow'
# loc <- 'Boulder Lake'
# loc <- 'Below Stagecoach Dam'
# loc <- 'Fruita A'
# loc <- 'Fruita B'
# loc <- 'Fruita NT'
# loc <- 'Fruita W'
# loc <- 'Fruita C'
# loc <- 'Fruita F'
# loc <- 'Gunnison'
loc <- 'Kerbel'                      
# loc <- 'Legacy'
# loc <- 'Molina'
# loc <- 'Stagecoach'
# loc <- 'The Ranch'
# loc <- 'Upper Yampa'
# loc <- 'Yellow Jacket'
# loc <- 'North Sand Creek'

all_sites <- c(
  'ARDEC','AVRC STAR','AVRC Cowpea','Barley','Berthoud','Big Hollow','Boulder Lake',
  'Below Stagecoach Dam','Fruita A','Fruita B','Fruita NT','Fruita W','Fruita C','Fruita F',
  'Gunnison','Kerbel','Legacy','Molina','Stagecoach','The Ranch','Upper Yampa',
  'Yellow Jacket','North Sand Creek'
)
if (!exists("loc")) stop("Please set 'loc' to one of the known sites.")
if (!loc %in% all_sites) stop(paste("Unknown 'loc':", loc))
```

```{r, include=FALSE}
# ---- TZ normalization helpers ----
normalize_to_denver <- function(x){
  if (inherits(x, "POSIXct")) {
    tzx <- attr(x, "tzone")
    if (is.null(tzx) || tzx == "") {
      return(lubridate::force_tz(x, "America/Denver"))
    } else {
      return(lubridate::with_tz(x, "America/Denver"))
    }
  } else if (is.character(x)) {
    parsed <- suppressWarnings(lubridate::parse_date_time(
      x, orders = c("Y-m-d H:M:S","Y-m-d H:M","m/d/Y H:M:S","m/d/Y H:M","Y-m-d"),
      tz = "America/Denver"
    ))
    return(lubridate::force_tz(parsed, "America/Denver"))
  } else {
    return(x)
  }
}

filter_dataframe <- function(df, selected_location, include_blanks = FALSE) {
  if (include_blanks) {
    filtered_df <- df %>% dplyr::filter(location.name == selected_location)
  } else {
    filtered_df <- df %>% dplyr::filter(location.name == selected_location & event.type != "Lab Blank")
  }
  filtered_df$event.type     <- as.factor(filtered_df$event.type)
  filtered_df$event.count    <- as.factor(filtered_df$event.count)
  filtered_df$location.name  <- as.factor(filtered_df$location.name)
  filtered_df$treatment.name <- as.factor(filtered_df$treatment.name)
  filtered_df <- filtered_df %>% dplyr::mutate(collected_local = normalize_to_denver(collected))
  filtered_df$collected_disp <- format(filtered_df$collected_local, "%m/%d/%Y %H:%M")
  filtered_df
}

filtered_df <- filter_dataframe(dat, loc, include_blanks = FALSE)

# Canonical event date (one per event), facet label
event_lookup <- filtered_df %>%
  dplyr::mutate(collected_date = as.Date(collected_local)) %>%
  dplyr::group_by(event.count) %>%
  dplyr::summarise(n_dates = dplyr::n_distinct(collected_date),
                   event_date = min(collected_date, na.rm = TRUE),
                   .groups = "drop")
filtered_df <- filtered_df %>% dplyr::left_join(event_lookup %>% dplyr::select(event.count, event_date), by = "event.count")
filtered_df <- filtered_df %>% dplyr::mutate(
  event_facet = factor(event.count, levels = unique(event.count[order(event_date)]))
)
label_map <- filtered_df %>% dplyr::select(event_facet, event_date) %>% dplyr::distinct()
event_labeller <- function(values) setNames(paste0(values, "\n", format(label_map$event_date[match(values, label_map$event_facet)], "%m-%d")), values)
```


**Location Selected: <span style="color:#4CAF50">`r loc`</span>**

```{r, include=FALSE}
# Export selected-site CSV
csv_data <- function(df, location_name) {
  location_data <- df %>% dplyr::filter(location.name == location_name)
  folder_name <- "site_selector_temporary_results"
  if (!file.exists(folder_name)) dir.create(folder_name)
  file_name <- paste0(folder_name, "/", location_name, "_data_", format(Sys.Date(), "%Y-%m-%d"), ".csv")
  write.csv(location_data, file = file_name, row.names = FALSE)
  return(file_name)
}
file = csv_data(filtered_df, loc)
```

```{r}
# Subsets
analytes_plot1 <- c("Nitrogen, Nitrate (As N)", "Nitrogen, Nitrite  (As N)", "Nitrogen, Total Kjeldahl")
analytes_plot2 <- c("Phosphorus, Total (As P)", "Phosphorus, Total Orthophosphate (as P)", "Suspended Solids (Residue, Non-Filterable)")
analytes_plot3 <- setdiff(unique(filtered_df$analyte), c(analytes_plot1, analytes_plot2))

N_df    <- filtered_df %>% dplyr::filter(analyte %in% analytes_plot1)
P_df    <- filtered_df %>% dplyr::filter(analyte %in% analytes_plot2)
Misc_df <- filtered_df %>% dplyr::filter(analyte %in% analytes_plot3)
```

**CSV Export of selected site data saved as:** `r file`

# Events Captured
```{r}
unique_treatments <- filtered_df %>%
  dplyr::select(treatment.name, event.count, event_date) %>%
  dplyr::distinct() %>%
  dplyr::group_by(treatment.name, event.count) %>%
  dplyr::summarise(
    collected = paste(sort(unique(format(event_date, "%Y-%m-%d"))), collapse = ", "),
    .groups = "drop"
  ) %>%
  dplyr::arrange(treatment.name, event.count)

DT::datatable(unique_treatments, caption = "Unique Treatments, Event Counts, and Collection Dates (YYYY-MM-DD)")
```


TODO: add table of reg 31 detections 
## use filtered_df, how do i display a table of just sample ID, collection date, and the analyte name, the value of that analyte, and the CDPHE regulations and EPA drinking water regulation for said analyte (should be two standards for that analyte), you don't want a giant data frame you want only the ones that do not meet the standards, and an extra column for which standard was triggered and why it is on the list, if it triggers both, then have both listed in that column (is one triggered, or both?) 
Create a dictionary? with all of the regulation values 

[EPA — National Primary Drinking Water Regulations](https://www.epa.gov/ground-water-and-drinking-water/national-primary-drinking-water-regulations)

[EPA Nutrient Criteria Manual: Lakes & Reservoirs](https://www.epa.gov/sites/default/files/2018-10/documents/nutrient-criteria-manual-lakes-reservoirs.pdf)

EPA analyte thresholds:
pH: 6.5-8.5
EC:
Phosphorus, total orthophosphate:
phosphorus, total: 0.0001 mg/L
total dissolved solids (residue, filterable): 500 mg/L
nitrogen, nitrate: 10 mg/L
nitrogen, nitrite: 1 mg/L
nitrogen, total kjeldahl:
suspended solids (residue, non-filterable):

CDPHE analyte thresholds:
pH: 6.5-9
nitrogen, nitrate: 10 mg/L
nitrogen, nitrite: 1 mg/L
Total phosphorus: .17 mg/L



```{r}
# Reg 31 exceedance table from filtered_df

# Standards dictionary 
standards <- tibble::tribble(
  ~analyte_key, ~type,   ~epa_min, ~epa_max, ~epa_threshold, ~cdphe_min, ~cdphe_max, ~cdphe_threshold,
  "pH",         "range",  6.5,       8.5,        NA_real_,       6.5,        9.0,          NA_real_,
  "NO3",        "max",    NA_real_,  NA_real_,   10,             NA_real_,   NA_real_,     10,
  "NO2",        "max",    NA_real_,  NA_real_,   1,              NA_real_,   NA_real_,     1,
  "TP",         "max",    NA_real_,  NA_real_,   0.0001,         NA_real_,   NA_real_,     0.17,
  "OP",         "max",    NA_real_,  NA_real_,   NA_real_,       NA_real_,   NA_real_,     NA_real_,   
  "TDS",        "max",    NA_real_,  NA_real_,   500,            NA_real_,   NA_real_,     NA_real_,
  "TSS",        "max",    NA_real_,  NA_real_,   NA_real_,       NA_real_,   NA_real_,     NA_real_,  
  "EC",         "max",    NA_real_,  NA_real_,   NA_real_,       NA_real_,   NA_real_,     NA_real_,   
  "TKN",        "max",    NA_real_,  NA_real_,   NA_real_,       NA_real_,   NA_real_,     NA_real_    
)

# 2) Helper: normalize analyte names to keys in 'standards'
map_analyte_to_key <- function(x) {
  x_low <- tolower(x)
  dplyr::case_when(
    str_detect(x_low, "^ph$") ~ "pH",
    str_detect(x_low, "nitrate") ~ "NO3",
    str_detect(x_low, "nitrite") ~ "NO2",
    str_detect(x_low, "total kjeldahl") ~ "TKN",
    str_detect(x_low, "total \\(?as p\\)?$") ~ "TP",
    str_detect(x_low, "total orthophosphate") ~ "OP",
    str_detect(x_low, "dissolved solids") ~ "TDS",
    str_detect(x_low, "suspended solids") ~ "TSS",
    str_detect(x_low, "specific conductance|^ec$") ~ "EC",
    TRUE ~ NA_character_
  )
}

# 3) Coalesce possible sample ID columns → 'sample_id'
sample_id_col <- coalesce(
  filtered_df$sample_id %>% suppressWarnings(),
  filtered_df$SampleID %>% suppressWarnings(),
  filtered_df$sample.id %>% suppressWarnings(),
  filtered_df$SAMPLE_ID %>% suppressWarnings(),
  filtered_df$Sample_ID %>% suppressWarnings()
)
filtered_df <- filtered_df %>%
  mutate(sample_id = sample_id_col)

# 4) Prepare data & join standards
df_std <- filtered_df %>%
  mutate(
    analyte_key = map_analyte_to_key(analyte),
    value = suppressWarnings(as.numeric(result)),
    collected_date = as.Date(collected)
  ) %>%
  left_join(standards, by = "analyte_key")

# 5) Compute exceedances with clear messages
exceed_logic <- function(val, type, e_min, e_max, e_thr, c_min, c_max, c_thr, ak) {
  msgs <- character(0)
  trig <- character(0)

  if (is.na(val) || is.na(type)) return(list(triggered = NA_character_, why = NA_character_))

  if (type == "range") {
    # EPA range
    if (is.finite(e_min) && is.finite(e_max)) {
      if (val < e_min || val > e_max) {
        trig <- c(trig, "EPA")
        msgs <- c(msgs, sprintf("EPA %s outside %.2f–%.2f (value=%.3g)", ak, e_min, e_max, val))
      }
    }
    # CDPHE range
    if (is.finite(c_min) && is.finite(c_max)) {
      if (val < c_min || val > c_max) {
        trig <- c(trig, "CDPHE")
        msgs <- c(msgs, sprintf("CDPHE %s outside %.2f–%.2f (value=%.3g)", ak, c_min, c_max, val))
      }
    }
  } else if (type == "max") {
    # EPA max
    if (is.finite(e_thr) && val > e_thr) {
      trig <- c(trig, "EPA")
      msgs <- c(msgs, sprintf("EPA %s > %.3g (value=%.3g)", ak, e_thr, val))
    }
    # CDPHE max
    if (is.finite(c_thr) && val > c_thr) {
      trig <- c(trig, "CDPHE")
      msgs <- c(msgs, sprintf("CDPHE %s > %.3g (value=%.3g)", ak, c_thr, val))
    }
  }

  if (length(trig) == 0) {
    list(triggered = "None", why = NA_character_)
  } else {
    list(triggered = paste(unique(trig), collapse = " & "),
         why = paste(msgs, collapse = " | "))
  }
}

res <- df_std %>%
  rowwise() %>%
  mutate(out = list(exceed_logic(
    val = value, type = type,
    e_min = epa_min, e_max = epa_max, e_thr = epa_threshold,
    c_min = cdphe_min, c_max = cdphe_max, c_thr = cdphe_threshold,
    ak = analyte_key
  ))) %>%
  unnest_wider(out) %>%
  ungroup()

# 6) Build compact violation table (only triggered rows w/ known standards)
reg31_exceedances <- res %>%
  filter(!is.na(type)) %>%                         # we have a rule
  filter(!is.na(value)) %>%                        # numeric value present
  filter(triggered != "None") %>%                  # only violations
  transmute(
    sample_id = sample_id,
    collected_date = collected_date,
    analyte = analyte,
    value = value,
    EPA_standard =
      dplyr::case_when(
        type == "range" & is.finite(epa_min) & is.finite(epa_max) ~
          sprintf("%.2f–%.2f", epa_min, epa_max),
        type == "max" & is.finite(epa_threshold) ~
          sprintf("≤ %.3g", epa_threshold),
        TRUE ~ NA_character_
      ),
    CDPHE_standard =
      dplyr::case_when(
        type == "range" & is.finite(cdphe_min) & is.finite(cdphe_max) ~
          sprintf("%.2f–%.2f", cdphe_min, cdphe_max),
        type == "max" & is.finite(cdphe_threshold) ~
          sprintf("≤ %.3g", cdphe_threshold),
        TRUE ~ NA_character_
      ),
    triggered,                                     # "EPA", "CDPHE", or "EPA & CDPHE"
    why                                            # human-readable reason(s)
  ) %>%
  arrange(collected_date, analyte, desc(value))

reg31_exceedances

```





# Interactive Box & Whisker Plot
```{r, warning=FALSE}
create_boxplot <- function(df, selected_location) {
  tryCatch({
    analytes <- unique(df$analyte.abbr)
    first_analyte <- analytes[1]
    df_filtered <- df[df$analyte.abbr == first_analyte, ]
    p <- ggplot(df_filtered, aes(x = treatment.name, y = as.numeric(result), fill = treatment.name)) +
      geom_boxplot(position = position_dodge(0), na.rm = TRUE) +
      geom_jitter(width = 0.2, size = 1.5, alpha = 0.6, na.rm = TRUE) +
      facet_grid(analyte.abbr ~ event_facet, scales = "free_y", space = "free_x",
                 labeller = labeller(event_facet = event_labeller)) +
      theme_minimal() +
      labs(title = paste("Box-and-Whisker plots for Location:", selected_location),
           x = "Event Type", y = "Result", fill = "Event Type")
    ggplotly(p, tooltip = c("y"))
  }, error = function(e) {
    cat("An error occurred:", conditionMessage(e), "\n"); NULL
  })
}
create_boxplot(filtered_df, loc)
```

```{r, fig.height=20, fig.width=12}
# dynamic x-axis in static plots
if (length(levels(as.factor(filtered_df$treatment.name))) > 1) {
  x_axis_var_name <- "treatment.name"
} else {
  x_axis_var_name <- "event.type"
}
```

# Static Bar Plots (Per Event) — with Error Bars
```{r}
library(ggplot2); library(dplyr); library(tools)

create_and_save_bar_plot_event <- function(df, output_dir, file_name, plot.title, x_axis_var) {
  tryCatch({
    if (!dir.exists(output_dir)) dir.create(output_dir, recursive = TRUE)
    df <- df %>% dplyr::mutate(result = suppressWarnings(as.numeric(result))) %>% dplyr::filter(is.finite(result))

    # summary stats per event facet, analyte, and x-axis (treatment/event.type)
    summary_df <- df %>%
      dplyr::group_by(.data[[x_axis_var]], analyte.abbr, event_facet) %>%
      dplyr::summarise(mean = mean(result, na.rm = TRUE),
                       sd = sd(result, na.rm = TRUE),
                       n = dplyr::n(),
                       .groups = "drop")

    # facet ordering & labels
    summary_df$event_facet <- factor(summary_df$event_facet, levels = levels(df$event_facet))

    file_path_portrait  <- file.path(output_dir, file_name)
    file_path_landscape <- file.path(output_dir, paste0(tools::file_path_sans_ext(file_name), "_landscape.jpg"))

    bar_plot <- ggplot(summary_df, aes(x = .data[[x_axis_var]], y = mean, fill = .data[[x_axis_var]])) +
      geom_bar(stat = "identity", position = position_dodge(0), color = "black") +
      geom_errorbar(aes(ymin = pmax(mean - sd, 0), ymax = mean + sd),
                    width = 0.2, position = position_dodge(0)) +
      # raw points (jitter) in background
      geom_jitter(data = df, aes(x = .data[[x_axis_var]], y = result), width = 0.2, alpha = 0.6,
                  size = 1, show.legend = FALSE) +
      facet_grid(analyte.abbr ~ event_facet, scales = "free_y", space = "free_x",
                 labeller = labeller(event_facet = event_labeller)) +
      theme_minimal() +
      theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 12),
            strip.text  = element_text(size = 12),
            legend.position = "bottom") +
      labs(title = plot.title, x = "Event Type", y = "Mean Result", fill = "Event Type") +
      scale_fill_brewer(palette = "Pastel1")

    ggsave(file_path_portrait,  bar_plot, width = 8.5, height = 11, units = "in")
    ggsave(file_path_landscape, bar_plot, width = 11, height = 8.5, units = "in")
    bar_plot
  }, error = function(e) { message("Error in create_and_save_bar_plot_event: ", e$message); NULL })
}

# Calls
bar_N    <- create_and_save_bar_plot_event(N_df, "./site_selector_temporary_results", "bar_N.jpg", "Forms of Nitrogen (per Event)", x_axis_var_name); bar_N
bar_P    <- create_and_save_bar_plot_event(P_df, "./site_selector_temporary_results", "bar_P.jpg", "Forms of Phosphorus (per Event)", x_axis_var_name); bar_P
bar_Misc <- create_and_save_bar_plot_event(Misc_df, "./site_selector_temporary_results", "bar_Misc.jpg", "Water Quality Analytes (per Event)", x_axis_var_name); bar_Misc
```

# Annual Means by Analyte & Treatment (Error Bars)
```{r}
create_facet_bar_plot_annual <- function(df, output_dir, file_name, x_axis_var, stratify_by_method = FALSE) {
  tryCatch({
    if (!dir.exists(output_dir)) dir.create(output_dir, recursive = TRUE)
    df <- df %>% dplyr::mutate(result = suppressWarnings(as.numeric(result))) %>% dplyr::filter(is.finite(result))

    # Ensure "Inflow" (if present) is first in x-axis
    if (x_axis_var %in% names(df)) {
      df[[x_axis_var]] <- factor(df[[x_axis_var]], levels = c("Inflow", setdiff(unique(df[[x_axis_var]]), "Inflow")))
    }

    analyte_units <- df %>% dplyr::select(analyte.abbr, units) %>% dplyr::distinct()

    if (stratify_by_method) {
      summary_df <- df %>%
        dplyr::group_by(.data[[x_axis_var]], analyte.abbr, method.name) %>%
        dplyr::summarise(mean = mean(result, na.rm = TRUE), sd = sd(result, na.rm = TRUE), n = dplyr::n(), .groups = "drop")
      p <- ggplot(summary_df, aes(x = .data[[x_axis_var]], y = mean, fill = method.name)) +
        geom_bar(stat = "identity", position = position_dodge(width = 0.7), color = "black") +
        geom_errorbar(aes(ymin = pmax(mean - sd, 0), ymax = mean + sd),
                      width = 0.2, position = position_dodge(width = 0.7))
    } else {
      summary_df <- df %>%
        dplyr::group_by(.data[[x_axis_var]], analyte.abbr) %>%
        dplyr::summarise(mean = mean(result, na.rm = TRUE), sd = sd(result, na.rm = TRUE), n = dplyr::n(), .groups = "drop")
      p <- ggplot(summary_df, aes(x = .data[[x_axis_var]], y = mean, fill = .data[[x_axis_var]])) +
        geom_bar(stat = "identity", position = "dodge", color = "black") +
        geom_errorbar(aes(ymin = pmax(mean - sd, 0), ymax = mean + sd),
                      width = 0.2, position = position_dodge(width = 0.9))
    }

    # facet labels include units
    facet_labels <- analyte_units %>%
      dplyr::mutate(lab = paste0(analyte.abbr, " (", units, ")")) %>%
      tibble::deframe()

    p <- p +
      facet_wrap(~ analyte.abbr, scales = "free_y", labeller = as_labeller(facet_labels)) +
      theme_minimal() +
      theme(axis.text.x = element_text(angle = 45, hjust = 1),
            strip.text = element_text(size = 10),
            legend.position = "bottom") +
      labs(title = ifelse(stratify_by_method, "Annual Mean by Analyte (Stratified by Method)", "Annual Mean by Analyte"),
           x = "Event Type", y = "Mean Result",
           fill = ifelse(stratify_by_method, "Method", x_axis_var)) +
      scale_fill_brewer(palette = "Pastel1") +
      coord_cartesian(ylim = c(0, NA))

    file_path <- file.path(output_dir, file_name)
    ggsave(file_path, p, width = 10, height = 8, units = "in")
    p
  }, error = function(e) { message("Error in create_facet_bar_plot_annual: ", e$message); NULL })
}

facet_bar_without_method <- create_facet_bar_plot_annual(filtered_df, "./site_selector_temporary_results", "facet_bar_analytes_annual.jpg", x_axis_var_name, stratify_by_method = FALSE); facet_bar_without_method
facet_bar_with_method    <- create_facet_bar_plot_annual(filtered_df, "./site_selector_temporary_results", "facet_bar_analytes_method_annual.jpg", x_axis_var_name, stratify_by_method = TRUE); facet_bar_with_method
```

# Raw Data
```{r}
DT::datatable(
  filtered_df %>%
    dplyr::mutate(collected = collected_disp) %>%
    dplyr::select(-collected_disp, -collected_local)
)
```
